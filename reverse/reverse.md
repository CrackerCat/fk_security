# reverse
	花指令，代码混淆，代码加壳加固(把真正的代码逻辑进行加密)，反调试,
## 花指令
	如果程序中包含的花指令IDA Pro无法识别或识别到了后一条指令中，将会对后续部分指令的分析和函数识别产生严重影响。简单的说就是在代码中混入一些垃圾数据阻碍你的静态分析。
### 可执行花指令
	执行前后不改变任何寄存器的值(当然eip这种除外)，同时这部分代码也会被反汇编器正常识别。 这种花指令可以破坏反编译的分析,使得栈指针在反编译引擎中出现异常(栈指针实际上是没有问题的,只不过反编译引擎还有待完善的空间)。
### 不可执行花指令
	利用反汇编器线性扫描算法的缺陷使得静态分析的时候会看到一些错误的代码。
### 特殊花指令
	不会影响反汇编和反编译，只是单纯的混淆视听。 这些指令相当于等价替换。
### 基本的花指令插入方法
	1. 使用jnz + jz方法跳过垃圾字节的方式，来插入花指令。
		1.1 应对措施：patch方法 a. 将无法解析的位置转化为数据，然后把跳转的位置转化为code,其他部分nop掉。
---
## re 技巧
### 调试法
	所需的信息在内存中。

## tools
- z3 线性规约求解器 
- sage 求公式
- PEID 查壳
- IAT 导入表重建工具
- ltrace ： 库追踪,也可以查看系统调用
- strace ：系统调用追踪
- ptrace系统调用 ：用于附加到进程上，并访问进程的代码、数据、堆栈和寄存器。 
---

## topic
### maze
  *#的组合构成maze,需要推出上下左右是哪几个字符代替。

---
## packer
### upx
- upx -d file #unpack

---
## checksum
1. 查表法实现校验
2. 阅读源码，思考破解


---
## hash
### md5
  128bit,每四位转一个16进制数，就一共32个数字。有时候有16个数字的hash值，是将32位md5去掉前八位，去掉后八位得到的。
#### openssl c
1. MD5_Init(MD5_CTX *c) : 初始化 MD5 Contex, 成功返回1,失败返回0
2. MD5_Update(MD5_CTX *c, const void *data, size_t len); : 循环调用此函数,可以将不同的数据加在一起计算MD5,成功返回1,失败返回0.
3. MD5_Final(unsigned char *md, MD5_CTX *c); : 输出MD5结果数据,成功返回1,失败返回0

## other
### 函数以endbr指令开始
- 运行fxxk_cet.py脚本破解，恢复函数签名。
