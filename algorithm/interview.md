# interview
## algorithm
	对于算法的实现，python代码比较简洁，容易实现，暂使用 python 语言刷题。
### 1. 两数之和
	以空间换时间。
	增加一个 Map 记录已经遍历过的数字及其对应的索引值。这样当遍历一个新数字的时候就去 Map 里查询 target 与该数的差值 diff 是否已经在前面的数字中出现过，查询时间从 O(n）-> O(logn)。
### 0002. 两数相加
	链表。
### 0003. 无重复字符的最长子串
	题目要求连续， 我们考虑使用滑动窗口。滑动窗口内是无重复字符的。每走一步判断一次。
	hash表。
### 5. 最长回文子串
	暴力：O(n^3)
	extend: O(n^2)
### 0011. 盛最多水的容器
	双指针 + 场景语义理解。
### 15. 三数之和
	问题转化。
	排序。
	双指针。
### 17. 电话号码的字母组合
	回溯法。由于要求所有的可能性，因此考虑使用回溯法进行求解。回溯是一种通过穷举所有可能情况来找到所有解的算法。
	笛卡尔积。
### 0019. 删除链表的倒数第 N 个节点
	一趟遍历 + 始终保持第N个。
### 20. 有效的括号
	用栈实现括号匹配。
### 21. 合并两个有序链表
	迭代。
	递归。每次计算开头元素，相互独立。
### 22. 括号生成
	回溯法 + dfs + 剪枝。
### 0024. 两两交换链表中的节点
	dummyHead节点简化操作。
### 33. 搜索旋转排序数组
	二分法。
### 0039. 组合总和
	回溯。
### 0040. 组合总和 II
	回溯法。
### 0046. 全排列
	回溯法。
### 0047. 全排列 II
	回溯法 + 排序前后比较去重。
### 0048. 旋转图像
	1. 对角线和y轴对称。 空间复杂度 O(1)
	2. 行列互换。空间复杂度 O(n)
### 0049. 字母异位词分组
	1. hashtable + 排序。
	2. 字母表作为哈希表，字母表出现次数作为key。类似桶排序。
### 50. Pow(x, n)
	递归二分求解。
	位运算。 n = ..1010.. = x^(ith) * x^(jth)..., 遍历位数即可。
### 53. 最大子序和
	dp。 以索引i结尾的列表的最大值。
	分治。max(maxsub(left) , maxsub(mid), maxsub(right))
### 55. 跳跃游戏
	回溯法dfs + hashmap。
	贪心，总计算当前可走的最远距离。
### 56. 合并区间
	排序。
### 60. 排列序列
	回溯 + 排列组合 + 规律。
### 0061. 旋转链表
	快慢指针法 + dummy。
### 0062. 不同路径
	动态规划。
### 66. 加一
	反向遍历。
### 0073. 矩阵置零
	状态压缩：重用置零元素，降低空间复杂度。 1. 重用空间技巧。
### 0075. 颜色分类
	计数排序。
	三指针法，又名挡板法。first 指向第一个集合最后一个元素的下一个元素；end指向 第三个集合的第一个元素的前一个元素。
### 0078. 子集
	回溯法。
### 0079. 单词搜索
	回溯 + 剪枝 + 空间重用降重。
### 0080. 删除排序数组中的重复项 II
	滑动窗口 = start + cur, 计数。
### 86. 分隔链表
	多指针定义。
### 0088. 合并两个有序数组
	归并排序。从后往前归并。
### 0090. 子集 II
### 91. 解码方法
	回溯法。由于重复计算导致超时。回溯往往会遇到重复解的问题。
	动态规划。后一个状态依赖前一个状态。dp[i]表示的意思是当前字符串的以索引 i 结尾的子问题。降低空间复杂度，只需要考虑前两个位置的数值。
### 92. 反转链表 II
	链表。
### 94. 二叉树的中序遍历
	中序遍历迭代方式。stack保存左子树根节点。 约束：len(stack) > 0 or root。
### 95. 不同的二叉搜索树 II
	二叉排序树 + 分治法。二叉排序树的任何子树都是BST；左右子树排列组合。
	规律法 --> 动态规划。每次新增加的数字大于之前的所有数字，所以新增加的数字出现的位置只可能是根节点或者是根节点的右孩子，右孩子的右孩子等。
### 96. 不同的二叉搜索树
	二叉排序树 + 分治法 + 记忆化递归 + 笛卡尔积。
### 98. 验证二叉搜索树
	分治法。比较根节点和子树所有节点的大小。
	中序遍历 + 遍历结果有序。
### 101. 对称二叉树
	dfs：同时递归遍历左右镜像子树。
### 102. 二叉树的层序遍历
	层次遍历 + 记录每层最后一个节点。
### 103. 二叉树的锯齿形层序遍历
	层次遍历(queue或者level递归) + reverse。
### 104. 二叉树的最大深度
	dfs: 1+max(d(左子树)，d(右子树))
	bfs: 记录层数。
### 108. 将有序数组转换为二叉搜索树
	dfs: 递归取中点，再遍历左右数组。
### 113. 路径总和 II
	dfs回溯法。
### 125. 验证回文串
	头尾双指针。
### 129. 求根节点到叶节点数字之和
	前序迭代遍历 + hash。
### 130. 被围绕的区域
	思维转化 + dfs + 防止走重复的节点的方法（首选结合题目，最后才用map）。
### 131. 分割回文串
	dfs + 
### 136. 只出现一次的数字
	位运算。
### 139. 单词拆分
	dfs. 超时
	dp. 对于问题(s, wordDict) 我们是否可以用(s', wordDict) 来解决。 其中 s' 是 s 的子序列， 当 s'变成寻常(长度为 0)的时候问题就解决了。 我们状态转移方程变成了这道题的难点。 dp[0] = true; dp[n] 表示 [0, ..., n-1] 是否能被拆分， 即 dp[n] = true if dp[i] && isWordDict(i, n-i), 0=<i<n else false。
	因此，dp[n]不单单是只跟n-1的状态有关，还可以跟0 - n-2子问题的状态都有关。
### 144. 二叉树的前序遍历
	前序迭代遍历。
### 146. LRU 缓存机制
	对于 get 和 put 请求：
	双链表（更新，头为最新，尾为最久未使用） + hashmap[key](复杂查找) + size + capacity
### 147. 对链表进行插入排序
	插入排序。
### 0150. 逆波兰表达式求值
	栈。逆波兰表达式完全不关心操作符的优先级。
### 152. 乘积最大子数组
	dp插入法。
	滑动窗口 《-- 连续 + dp。dp[n] 以第个n字符结尾的最大乘积。
### 153. 寻找旋转排序数组中的最小值
	二分查找 + 递归分治。
	单纯二分查找 + 如果左端点的值小于右端点的值则可以提前退出。
### 0155. 最小栈
### 160. 相交链表
	哈希法。
	双指针。A +B + C = C + B + A，距离相同。
### 167. 两数之和 II - 输入有序数组
	hashmap + 差值diff。
	头尾双指针。
### 169. 多数元素
	hashmap.
	投票算法。通过不断消除不同元素直到没有不同元素，剩下的元素就是我们要找的元素。count + majority.
### 172. 阶乘后的零
	数论。10 = 2*5，5比2的个数小。计算 n/5, n/25, ...找到所有因子。
### 0191. 位 1 的个数
	位运算。
### 0198. 打家劫舍
	dp。max(dp[i-2] + cur_ele, dp[i-1]) , 所以可以优化 dp数组。
### 199. 二叉树的右视图
	层次遍历 + level计数：取每层最后一个元素。
### 200. 岛屿数量
	dfs + 防止重复计算。
### 0201. 数字范围按位与
	位运算 + 性质：n 个连续数字求与的时候，前 m 位都是 1.
### 206. 反转链表
	迭代。带头结点，比较方便，操作统一化。不带头结点，使用 pre, cur, next变量遍历链表。
	递归。规则：链表第一个元素逆转后，就成了最后一个元素。
### 208. 实现 Trie (前缀树)
	前缀树即字典树 + dictTreeNode + list[] + isWord.
### 209. 长度最小的子数组
	连续 -> 滑动窗口 = start + cur + l。
### 215. 数组中的第K个最大元素
	快排 partition。
	最大堆 + priority_queue。
	直接排序。
### 0219. 存在重复元素 II
	hashmap。
### 220. 存在重复元素 III
	分桶排序 + 滑动窗口。
### 221. 最大正方形
	动态规划：dp[i][j] 表示以<i,j>为最后一个元素的矩形所能包含最大正方形的边长。dp[i][j] = max(dp[i][j], min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])+1). 初始状态1或0.
### 226. 翻转二叉树
	递归。
	迭代方式。层次遍历
### 227. 基本计算器 II
	中缀表达式 -> 后缀表达式：opcStack + opnStack + opc优先级。
### 229. 求众数 II
	摩尔投票法 -> 出现次数超过[n/k]的数字 —> 需要k-1个空间存数据 -> 需要再验证占比。空间复杂度为O(1).
### 230. 二叉搜索树中第K小的元素
	中序遍历。
### 232. 用栈实现队列
	栈的学习。
### 263. 丑数
	因式分解
### 0283. 移动零
	双指针。快慢指针，使用一个慢指针表示写指针，快指针表示读指针。快指针搜索非零元素，慢指针代替0元素。
	具体来说：读指针不断往后移动。如果遇到非 0，则将读到的值写入写指针，触发写指针移动（其他情况写指针不动），读指针走到头算法结束。slow 表示目标列表尾部元素的下一个元素，fast是遍历指针。
### 300. 最长递增子序列
	动态规划：dp[i]表示以i节点结尾的最长递增序列长度。
	动态规划：dp[i]表示长度为i+1的最长递增子序列的最后一个元素，且始终保持每个尾部元素最小。推导dp[i]严格递增的，反证法。
### 0342. 4 的幂 
	数论。如果一个数字 n 是 2 的幂次方，那么 n & (n - 1) 一定等于 0。
### 0371. 两整数之和
	位运算。异或是一种不进位的加减法。求与之后左移一位来可以表示进位。 所以 加法运算 = 异或 + 与运算（迭代）
### 401. 二进制手表
	笛卡尔积。
### 第 k 个数
	heapq + set。
### 17.23. 最大黑方阵
	dp: memo(i, j) = [top, left] 表示 (i, j) 上面有top个0，左边有left个0，从左到右从上到下遍历map，因此前一个跟后一个存在递推关系。O(n^3)。
### 16.16. 部分排序
	目的是 找到最小排序子数组。
	左右两次遍历。O(n)
### 437. 路径总和 III
	dfs：两次先序遍历。
	利用 hashmap 来避免重复计算：连续子数组求 和为k的子数组。
### 455. 分发饼干
	排序+贪心。
### 0504. 七进制数
	辗转相除法。
### 560. 和为K的子数组
	前缀和：前缀和，保存一个数组的前缀和，然后利用差分法得出任意区间段的和。O(n^2)
	hashmap + 连续累加和：hashmap[acc] = 出现次数； hashmap[acc-k] 就是 和为k的子数组。
### 0665. 非递减数列
	贪心算法。
### 821. 字符的最短距离 91
	数组遍历 ：(
### 0874. 模拟行走机器人
	hashtable: set查找障碍物需要优化时间效率。
### 912. 排序数组
	归并排序。 空间复杂度 O(n); 需要用一个新的数组存数据；记得拷贝数据。
### 1114. 按序打印
	信号量同步。sem_t, sem_init, sem_wait, sem_post。
### 1128. 等价多米诺骨牌对的数量
	hashmap。而对于key比较小的场景，可以用 状态压缩方法 构建 O（1024） 大小的空间，从而将O（n) -> O（1024）。
### 1143. 最长公共子序列
	dp[i][j] 表示 [0:li]和[0:lj]的最长公共子序列。初始状态-空字符串。递推公式-比较i和j字符。
### 1260. 二维网格迁移
	三次旋转法。
### 1332. 删除回文子序列
	
## design mode
### 单例模式（Singleton Pattern）
	单例模式：保证一个类只有一个实例。实现方法：判断实际是否存在，不存在，创建实际，存在直接返回。
	单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，因此对象需要被公用的场合适合使用，如多个模块使用同一个数据源连接对象等等。
	种类：
		1. 懒汉式。在你真正用到的时候才去实例化单例对象，延迟到你需要的时候才进行实例化，需要考虑线程安全。
		2. 饿汉式。是直接加载的，在类加载的时候，就会创建单例对象，不管你用不用得到。
	使用场景：
		1.要求生成唯一序列号的环境；
		2.在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；
		3.创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；
		4.需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当然，也可以直接声明为static的方式）
### 观察者模式（Observer Pattern）
	定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。
	使用场景：
		1. 关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。
		2. 事件多级触发场景。
		3. 跨系统的消息交换场景，如消息队列的处理机制。

	概念。
		a. Subject被观察者。定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的。职责：管理观察者并通知观察者。
		b. Observer观察者。观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。
		c. ConcreteSubject。定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。
		d. ConcreteObserver。每个观察在接收到消息后的处理反应是不同，各个观察者有自己的处理逻辑。
### 工厂模式
	用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
	Product为抽象产品类负责定义产品的共性，实现对事物最抽象的定义。
	Creator为抽象创建类，也就是抽象工厂，具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。

## 浏览器输入URL后的流程
### DNS域名解析
	首先，浏览器向本地 DNS 服务器发起请求，由于本地 DNS 服务器没有缓存不能直接将域名转换为 IP 地址，需要采用递归或者迭代查询的方式（图 3）依次向根域名服务器、顶级域名服务器、权威域名服务器发起查询请求，直至找到一个或一组 IP 地址，返回给浏览器。
	迭代查询。
	递归查询。
### 建立TCP连接
	浏览器再通过系统调用 Socket 接口与服务器 443 端口进行通信，整个过程可以分解为建立连接、发送 HTTP 请求、返回 HTTP 响应、维持连接、释放连接五个部分。
	
	a. 三次握手。
	b. 若https, 则TLS 四次握手。
### 发送HTTP请求
	建立了TCP连接后，就可以向服务器发起HTTP请求。
	一个请求报文由请求行、请求头、空行、实体（Get 请求没有）组成。
	请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。
### 服务器处理请求
	web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。
### 返回响应结果
	在HTTP里，有请求就会有响应，哪怕是错误信息。
	一个响应报文格式基本等同于请求报文，由响应行、响应头、空行、实体组成。
	在响应结果中都会有个一个HTTP状态码。
### 维持连接
	完成一次 HTTP 请求后，服务器并不是马上断开与客户端的连接。
	在 HTTP/1.1 中，Connection: keep-alive 是默认启用的，表示持久连接，以便处理不久后到来的新请求，无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。
	注意，HTTP keep-alive 和 TCP keep-alive 虽然都是一种保活机制，但是它们完全不相同，一个作用于应用层，一个作用于传输层。
### 关闭TCP连接
	为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。
	四次握手。
### 浏览器解析HTML
	现代浏览器是一个及其庞大的大型软件，在某种程度上甚至不亚于一个操作系统，它由多媒体支持、图形显示、GPU 渲染、进程管理、内存管理、沙箱机制、存储系统、网络管理等大大小小数百个组件组成。
	浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。
### 浏览器布局渲染
	根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。
### reference
- https://zhuanlan.zhihu.com/p/43369093 : 简介

## db
### 左连接和右连接
	左连接（left join)：返回包括左表中的所有记录和右表中连接字段相等的记录。
	右连接（right join）：返回包括右表中的所有记录和左表中连接字段相等的记录。
	inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。
	full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。
### group by
	分组查询

## 协程和纤程
### 协程, coroutine。
	1. 协程是用户模式下的轻量级线程。
	2. 协程的调度完全有应用程序来控制。
	3. 一个线程可以包含一个或多个协程。
	4. 协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下纹和栈保存起来，在切换回来时恢复先前保运的寄存上下文和栈。
	5. 协程能保留上一次调用时的状态。
	6. Windows下的实现叫纤程。
### 纤程
	Microsoft 在操作系统中增加了纤程（Fiber）。纤程与线程对比，有如下的特性：
	1. 线程是在Windows内核中实现的， 纤程是在用户模式下实现的。
	2. 一个线程可以包含一个或多个纤程。
	3. 内核会对线程进行抢占式调度，线程一次只能执行一个纤程的代码。
	4. 除非正在运行的纤程显式的切换到另一个纤程，否则其他纤程将无法运行。
## security
	应用安全。
	基础安全。传统基础安全领域，在通用产品能力上，一般分为三大件：网络层的防DDoS、主机层的防入侵和应用层的防漏洞。
	数据安全。敏感数据挖掘，脱密等。
	安全攻防。
	资深安全SDLC。
	安全研发工程师。
### 程序分析	
	浅层次bug发现：对于android，使用android lint插件。对于ios，使用bdoclint插件。
	华为云 codetrick 静态分析工具。
#### 思考
- 字节终端部门，采用时分复用的手段，白天反馈浅层次的bug，晚上对整个项目总体检测。
## Formal Verification
	形式化验证是用数学方法去证明我们的系统是无 Bug 的。

## offer
	1. 腾讯 csig 累，好像 csig, pcg 轻松，钱少。
	2. tencent, TEG看起来还不错。
	2. 字节。10-10点半。日薪。大小周。大周周日上班。
	3. 提前批 7-8 月；秋招 9 月。
	4. 根据牛客薪资对比： 华为 > 字节跳动 > tencent > 美团 > 
	5. 深信服正在往云计算转型。
	6. 字节client infrastructure部门 终端技术团队静态检测方向：
### 面试技巧
	1. 自我介绍简短。
	2. 不懂就不懂；关联内容的介绍。
	3. 反问环节：业务？加入团队，负责什么？作为新人，怎么更快融入团队？团队氛围？需要具备哪些技能？
	4. 多学面试经验？
### 阿里
#### 绩效考核
	1. 强制正态分析，业绩图：3-6-1，打分：2.5-5。
### 滴滴
	网约车和国际化部门比较好，其次是自动驾驶无人车。
### 腾讯
	WXG、IEG、TEG。
	喜欢有梦想、爱学习、有实力的人。

### baidu深圳安全一面
-  TCP & UDP
-  单例模式，观察者模式
-  进程和线程
-  进程通信
-  管道的概念。有名管道。
-  页表和物理地址
-  三次握手和四次挥手
-  TLS
-  浏览器输入URL后的流程
-  进程的状态
-  死锁的必要条件
-  一道算法题：环形链表 - hashmap or 快慢指针
-  一道思考题：如何高效地找出唯一患病的人？

### 百度基础架构部 - 数据库内核存储
- 文件读写方式，直写和回写。
- tcp粘包解决办法。

#### 面评
和辉哥这边面聊了会，觉得你这边可能还需要再好好准备准备，对于自己做过的项目要说清楚，不是说的越多越好，就简单的把问题答到核心点上就行。基础的部分也需要再加强一些，可能也是刚开始参与校招提前批吧，多多准备准备。如果还有其他感兴趣的岗位，我们这边也可以再推荐一下

### 快手移动安全实习 一面
- 写exp思路？ √
- bug会造成哪些漏洞？√
- ASLR的绕过思路。√
- 混淆vmp

### 快手移动安全实习 二面
- 对app安全的理解，应该从哪几个方面做？- 应用层(混淆，逆向) + 系统层(获取隐私数据，进行黑盒测试) ，快手白盒测试主要是server端。
- 竞品调研，了解对方的攻与防，例如，快手混淆编译器。
- 过去实习的话，估计是做竞品调研，做一些独立的工作。ctf的经历太短。
- 如果有漏洞，怎么跟同事argue？
- AOSP?

### 快手移动安全实习 hr面
- 自身反问
	- 工作base还有哪些？新人培养？
	- 如果有幸加入贵司，工作内容？有哪些痛点？公司在管理上有哪些支持？这岗位的加薪发展晋升通道是怎么设计的？团队规模？
	- 薪酬：只要有发展机会，我愿意接受贵司的薪酬标准，不知按规定这个岗位的薪酬标准是多少？
	- 保留底牌：当HR和面试官明确要雇佣你的时候，再谈薪资。对方不问，就不开口。
	- 还有什么问题吗？：隐含意思是想要了解你对公司的意向度、对公司有没有兴趣以及你找工作关注的问题。
		- 回答方式：明确表示感兴趣
	- 五险一金、补助、调薪等公司规章。
- 前几天，我们导师通知九月中旬就要开始论文讨论以及开题，必须待在实验室里写论文，这样的话，实习时间最多40天左右。
- 在公司工作，为啥决定考研？
- 快手安全方向：海量数据挖掘，安全算法研究，机器学习，逆向，威胁分析。

### 蚂蚁支付宝 - 后端一面
- linux操作系统的锁
- 红黑树，b, b+树 √
- 银行家算法的实现
- kafka 的生产者和消费者模型；消费失败怎么办？
- 自身的优点和亮点？
- 单例模式的种类？√
- 简历技能技术点的列举

### 字节云安全一面 - 数据隐私保护，脱敏等
- 项目交流。
- 内核：系统调用的实现。√
- 陷入内核的方式。√
- 算法题：链表归并。注意delete空间。√
- 归并排序的思路。 √

### 蚂蚁 - 数据风险
- 左连接和右连接。√

### 美团流量安全 - 数据安全
- AES的安全性
- XSS的类型 √

### 拼多多一面 - 安全工程师 38
- 了解区块链？

### 字节二面 100个人
- 介绍指针分析？
- 影响 python性能的因素？
- python GIL？
- 个人闪光点？哪些方面体现个人的能力？
- 管理能力？团队介绍？

### 面团二面
- api信息泄露漏洞检测系统？

### 百度搜索产品研发一面
- 复制构造函数为啥需要引用，构造函数初始化列表的初始顺序，share_ptr和unique_ptr的区别, vector和array的区别 √
- socket函数 与 三次握手的对应关系 √
- db的存储引擎√
- 协程和先程√

### 360样本分析一面
- 有没有分析过病毒？
- 了不了解流量分析，wareshark，加解密
- 脱壳
- 更喜欢做windows的

### 猿辅导应用安全工程师一面 22个人 10hc
- web漏洞，csrf漏洞，反序列化漏洞。
- codeql √
- 除了密码认证，还有哪些好的认证方法？
- fastjson or jsonfuzz
- 反问：贵司对于误报漏报的处理？

### 百度搜索产品研发二面
- 有哪些系统调用？
- tail命令的实现，读取后几行的思路 -> fseek -> 多读 -> 读多少？

### 微信支付-一面 已转微信安全
- 形式化验证？
- LRU?
- 项目介绍？
- 给一个patch链接？

### 微信安全一面
- [0,5) -> [0,2) 等概率？
- sql语句，查学生的平均成绩？
- 项目，非直接调用分析？
- 混淆项目，与ollvm的不同点？

### 阿里云安全
- 怎么实现一个能识别c代码的程序 -- 语法层次AST。  yacc 或者 bison?    半√

### 阿里云安全二面
- 漏洞的自动化利用性？
- 反调试？ √
- gdb的实现方式 ptrace？ √
- 脱过什么壳？
- 内核利用方式？
- ctf成绩？
- windows调试？

### 阿里云安全三面
- intel kernel页表更新机制？
- qemu容器逃逸漏洞？
- kernel fuzz?
- 美国闭源静态分析器 coverpy?

### 深信服一面
- 对于最新的安全动态，安全漏洞的研究？

### pdd二面
- 最长上升子序列？
- ebpf和其他模块的区别？
- linux内核的进程和线程的区别？

### 美团三面
- java项目？
- 为啥考研？

### 阿里集团安全一面 - 盒马iot 和 阿里生活 
- bpf
- 进程的调度方式
- 缓解机制
- kprobe
- kminer
- smech
- 怎么监控系统调用？

### pdd三面
- 溯源问题？
- 
